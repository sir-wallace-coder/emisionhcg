/**
 * üìÑ Endpoint para Generar PDF desde XML CFDI
 * 
 * Usa el SDK oficial de redoc.mx para convertir XMLs CFDI a PDF
 * 
 * @author CFDI Sistema Completo
 * @version 2.0.0
 */

const { supabase } = require('./config/supabase');
const jwt = require('jsonwebtoken');
const fetch = require('node-fetch');
const FormData = require('form-data');

// SDK de redoc.mx se cargar√° din√°micamente en la funci√≥n handler
// debido a que es un ES module y necesita import() din√°mico

/**
 * üöÄ FUNCI√ìN PARA SUBIR LOGO AUTOM√ÅTICAMENTE A REDOC
 * Convierte logo base64 a buffer y lo sube a la plataforma RedDoc
 * @param {string} logoBase64 - Logo en formato base64
 * @param {string} logoPath - Ruta donde se guardar√° en RedDoc (ej: assets/logos/RFC-logo.png)
 * @returns {boolean} - true si se subi√≥ exitosamente, false si fall√≥
 */
async function subirLogoARedoc(logoBase64, logoPath) {
    try {
        console.log('üöÄ SUBIR LOGO: Iniciando upload a RedDoc...');
        console.log('üìÅ SUBIR LOGO: Ruta destino:', logoPath);
        
        // Validar que tenemos API key
        if (!process.env.REDOC_API_KEY) {
            console.error('‚ùå SUBIR LOGO: REDOC_API_KEY no configurada');
            return false;
        }
        
        // Convertir base64 a buffer
        const base64Data = logoBase64.replace(/^data:image\/[a-z]+;base64,/, '');
        const logoBuffer = Buffer.from(base64Data, 'base64');
        
        console.log('üìä SUBIR LOGO: Tama√±o del buffer:', logoBuffer.length, 'bytes');
        
        // Crear FormData para el upload
        const formData = new FormData();
        formData.append('file', logoBuffer, {
            filename: logoPath.split('/').pop(), // Extraer solo el nombre del archivo
            contentType: 'image/png'
        });
        formData.append('path', logoPath); // Ruta completa en RedDoc
        
        // Realizar upload a RedDoc API
        const uploadResponse = await fetch('https://api.redoc.mx/v1/assets/upload', {
            method: 'POST',
            headers: {
                'Authorization': `Bearer ${process.env.REDOC_API_KEY}`,
                ...formData.getHeaders()
            },
            body: formData
        });
        
        console.log('üì° SUBIR LOGO: Status de respuesta:', uploadResponse.status);
        
        if (uploadResponse.ok) {
            const result = await uploadResponse.json();
            console.log('‚úÖ SUBIR LOGO: Upload exitoso:', result);
            return true;
        } else {
            const error = await uploadResponse.text();
            console.error('‚ùå SUBIR LOGO: Error en upload:', error);
            return false;
        }
        
    } catch (error) {
        console.error('üí• SUBIR LOGO: Excepci√≥n durante upload:', error.message);
        return false;
    }
}

/**
 * Funci√≥n para generar PDF v√≠a API HTTP directa (fallback)
 * Prueba diferentes endpoints y configuraciones
 */
async function generarPdfViaHttp(xmlContent, apiKey, stylePdf) {
    console.log('üîß REDOC HTTP: Usando endpoint oficial encontrado');
    
    // Endpoint correcto seg√∫n documentaci√≥n oficial encontrada por el usuario
    const endpoint = 'https://api.redoc.mx/cfdis/convert';
    console.log(`üåê REDOC HTTP: Endpoint oficial: ${endpoint}`);
    
    try {
        const response = await fetch(endpoint, {
            method: 'POST',
            headers: {
                'X-Redoc-Api-Key': apiKey,
                'Content-Type': 'application/json',
                'Accept': 'application/json'
            },
            body: JSON.stringify({
                xml: xmlContent,
                encoding: 'utf8',
                style_pdf: stylePdf || undefined
            })
        });
        
        console.log(`üìä REDOC HTTP: Status: ${response.status}`);
        console.log(`üìä REDOC HTTP: Headers:`, Object.fromEntries(response.headers.entries()));
        
        if (response.ok) {
            const result = await response.json();
            console.log('‚úÖ REDOC HTTP: PDF generado exitosamente con endpoint oficial');
            
            return {
                content: result.content,
                metadata: {
                    transactionId: response.headers.get('X-Redoc-Transaction-Id'),
                    totalPages: response.headers.get('X-Redoc-Pdf-Total-Pages'),
                    totalTime: response.headers.get('X-Redoc-Process-Total-Time'),
                    endpoint: endpoint
                }
            };
        } else {
            const errorText = await response.text();
            console.log(`‚ùå REDOC HTTP: Error ${response.status}: ${errorText}`);
            throw new Error(`HTTP ${response.status}: ${errorText}`);
        }
    } catch (error) {
        console.log(`‚ùå REDOC HTTP: Excepci√≥n:`, error.message);
        throw error;
    }
}

/**
 * Handler principal para generar PDF desde XML
 */
exports.handler = async (event, context) => {
    console.log('üìÑ GENERAR PDF: Request recibido:', event.httpMethod);
    
    // Headers CORS
    const headers = {
        'Access-Control-Allow-Origin': '*',
        'Access-Control-Allow-Headers': 'Content-Type, Authorization',
        'Access-Control-Allow-Methods': 'POST, OPTIONS',
        'Content-Type': 'application/json'
    };

    // Manejar preflight OPTIONS
    if (event.httpMethod === 'OPTIONS') {
        return {
            statusCode: 200,
            headers,
            body: JSON.stringify({ message: 'CORS preflight OK' })
        };
    }

    // Solo permitir POST
    if (event.httpMethod !== 'POST') {
        return {
            statusCode: 405,
            headers,
            body: JSON.stringify({ 
                error: 'M√©todo no permitido',
                metodos_soportados: ['POST', 'OPTIONS']
            })
        };
    }

    try {
        // Verificar autenticaci√≥n
        const authHeader = event.headers.authorization || event.headers.Authorization;
        if (!authHeader || !authHeader.startsWith('Bearer ')) {
            return {
                statusCode: 401,
                headers,
                body: JSON.stringify({ 
                    error: 'Token de autorizaci√≥n requerido',
                    formato: 'Bearer <token>'
                })
            };
        }

        const token = authHeader.substring(7);
        let usuario;
        
        try {
            usuario = jwt.verify(token, process.env.JWT_SECRET);
        } catch (jwtError) {
            return {
                statusCode: 401,
                headers,
                body: JSON.stringify({ 
                    error: 'Token inv√°lido o expirado'
                })
            };
        }

        console.log('üë§ GENERAR PDF: Usuario autenticado:', usuario.email);

        // Parsear body
        const body = JSON.parse(event.body || '{}');
        const { xmlId, stylePdf } = body;

        if (!xmlId) {
            return {
                statusCode: 400,
                headers,
                body: JSON.stringify({
                    error: 'ID del XML requerido',
                    parametros_requeridos: ['xmlId']
                })
            };
        }

        console.log('üìã GENERAR PDF: ID del XML:', xmlId);
        console.log('üé® GENERAR PDF: Estilo PDF:', stylePdf || 'default');

        // Verificar configuraci√≥n de API
        const redocApiKey = process.env.REDOC_API_KEY;

        if (!redocApiKey) {
            console.error('‚ùå GENERAR PDF: API Key de redoc.mx no configurada');
            return {
                statusCode: 500,
                headers,
                body: JSON.stringify({
                    error: 'Servicio de PDF no configurado',
                    mensaje: 'API Key de redoc.mx no disponible'
                })
            };
        }

        // Cargar SDK de redoc.mx din√°micamente (ES module)
        let Redoc;
        try {
            console.log('üöÄ GENERAR PDF: Cargando SDK @redocmx/client...');
            const redocModule = await import('@redocmx/client');
            Redoc = redocModule.default || redocModule;
            console.log('‚úÖ GENERAR PDF: SDK @redocmx/client cargado exitosamente');
        } catch (importError) {
            console.error('‚ùå GENERAR PDF: Error cargando SDK @redocmx/client:', importError.message);
            console.error('Stack:', importError.stack);
            return {
                statusCode: 500,
                headers,
                body: JSON.stringify({
                    error: 'SDK de PDF no disponible',
                    mensaje: `Error cargando @redocmx/client: ${importError.message}`,
                    timestamp: new Date().toISOString()
                })
            };
        }

        // Obtener XML de la base de datos
        console.log('üîç GENERAR PDF: Buscando XML en base de datos...');
        const { data: xmlData, error: xmlError } = await supabase
            .from('xmls_generados')
            .select('*')
            .eq('id', xmlId)
            .single();

        if (xmlError || !xmlData) {
            console.error('‚ùå GENERAR PDF: XML no encontrado:', xmlError?.message);
            return {
                statusCode: 404,
                headers,
                body: JSON.stringify({
                    error: 'XML no encontrado',
                    xmlId: xmlId
                })
            };
        }

        console.log('‚úÖ GENERAR PDF: XML encontrado');
        console.log('üìä GENERAR PDF: Estado XML:', xmlData.estado);
        console.log('üìÑ GENERAR PDF: Tama√±o XML:', xmlData.xml_content?.length || 0, 'caracteres');
        
        // üé® OBTENER DATOS DEL EMISOR PARA PERSONALIZACI√ìN
        let emisorData = null;
        try {
            // Extraer RFC del emisor del XML para buscar sus datos
            const xmlDoc = xmlData.xml_content;
            const rfcMatch = xmlDoc.match(/Rfc="([^"]+)"/i);
            const rfcEmisor = rfcMatch ? rfcMatch[1] : null;
            
            if (rfcEmisor) {
                console.log('üîç GENERAR PDF: RFC del emisor extra√≠do:', rfcEmisor);
                
                // Buscar datos del emisor (logo y color)
                const { data: emisor, error: emisorError } = await supabase
                    .from('emisores')
                    .select('id, rfc, nombre, logo, color')
                    .eq('rfc', rfcEmisor)
                    .single();
                
                if (emisor && !emisorError) {
                    emisorData = emisor;
                    console.log('‚úÖ GENERAR PDF: Datos del emisor encontrados:', {
                        rfc: emisor.rfc,
                        nombre: emisor.nombre,
                        tiene_logo: !!emisor.logo,
                        color: emisor.color
                    });
                } else {
                    console.log('‚ö†Ô∏è GENERAR PDF: Emisor no encontrado en BD, usando valores por defecto');
                }
            } else {
                console.log('‚ö†Ô∏è GENERAR PDF: No se pudo extraer RFC del XML');
            }
        } catch (emisorError) {
            console.error('‚ùå GENERAR PDF: Error obteniendo datos del emisor:', emisorError.message);
        }

        console.log('üöÄ GENERAR PDF: Usando SDK oficial de redoc.mx...');
        
        try {
            // Logs de diagn√≥stico para API Key
            console.log('üîë GENERAR PDF: API Key presente:', !!redocApiKey);
            console.log('üîë GENERAR PDF: API Key longitud:', redocApiKey ? redocApiKey.length : 0);
            console.log('üîë GENERAR PDF: API Key prefijo:', redocApiKey ? redocApiKey.substring(0, 10) + '...' : 'N/A');
            
            // Inicializar cliente de redoc.mx con API key seg√∫n documentaci√≥n oficial
            const redoc = new Redoc(redocApiKey);
            console.log('‚úÖ GENERAR PDF: Cliente @redocmx/client inicializado');
            
            // Cargar CFDI desde string XML usando m√©todo oficial del SDK
            const cfdi = redoc.cfdi.fromString(xmlData.xml_content);
            console.log('‚úÖ GENERAR PDF: CFDI cargado desde XML string');
            
            console.log('üîÑ GENERAR PDF: Convirtiendo CFDI a PDF usando SDK oficial...');
            console.log('üìä GENERAR PDF: Tama√±o XML para conversi√≥n:', xmlData.xml_content.length, 'caracteres');
            
            // üé® GENERAR ADDENDA XML PARA PERSONALIZACI√ìN CORPORATIVA
            let addendaXml = null;
            let hasCustomization = false;
            let logoStatus = 'no_logo';
            
            if (emisorData?.logo || emisorData?.color) {
                console.log('üé® GENERAR PDF: Creando addenda XML para personalizaci√≥n corporativa');
                
                // Crear addenda XML din√°micamente
                let addendaContent = `<?xml version="1.0" encoding="UTF-8"?>
<rd:redoc xmlns:rd="https://redoc.mx/addenda" 
          xsi:schemaLocation="https://redoc.mx/addenda https://redoc.mx/addenda/v1.0.0/schema.xsd" 
          xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
          version="1.0.0">
  <rd:style>
    <rd:pdf>
      <rd:settings>`;
      
                // üöÄ MANEJO INTELIGENTE DEL LOGO CORPORATIVO CON UPLOAD AUTOM√ÅTICO
                if (emisorData?.logo) {
                    console.log('üé® GENERAR PDF: Logo corporativo detectado en base de datos');
                    console.log('üìã GENERAR PDF: Tama√±o del logo:', emisorData.logo.length, 'caracteres base64');
                    
                    const logoPath = `assets/logos/${emisorData.rfc}-logo.png`;
                    
                    try {
                        // üöÄ INTENTAR SUBIR EL LOGO AUTOM√ÅTICAMENTE A REDOC
                        console.log('üöÄ GENERAR PDF: Intentando subir logo autom√°ticamente a RedDoc...');
                        const uploadSuccess = await subirLogoARedoc(emisorData.logo, logoPath);
                        
                        if (uploadSuccess) {
                            console.log('‚úÖ GENERAR PDF: Logo subido exitosamente a RedDoc:', logoPath);
                            logoStatus = 'uploaded_success';
                        } else {
                            console.log('‚ö†Ô∏è GENERAR PDF: No se pudo subir el logo, usando sin logo');
                            logoStatus = 'upload_failed';
                        }
                    } catch (uploadError) {
                        console.error('‚ùå GENERAR PDF: Error subiendo logo:', uploadError.message);
                        logoStatus = 'upload_error';
                    }
                    
                    // Agregar logo a la addenda (funcionar√° si se subi√≥ exitosamente)
                    if (logoStatus === 'uploaded_success') {
                        addendaContent += `
        <rd:section id="header">
          <rd:option id="logo" value="${logoPath}" />
          <rd:option id="logo-horizontal-align" value="center" />
          <rd:option id="logo-vertical-align" value="middle" />
          <rd:option id="logo-width" value="120" />
          <rd:option id="logo-height" value="60" />
        </rd:section>`;
                        hasCustomization = true;
                    } else {
                        console.log('üìã GENERAR PDF: Omitiendo logo en addenda (no disponible en RedDoc)');
                    }
                }
                
                // ‚úÖ COLOR CORPORATIVO (FUNCIONA DIRECTAMENTE)
                if (emisorData?.color) {
                    console.log('‚úÖ GENERAR PDF: Aplicando color corporativo (funcional):', emisorData.color);
                    addendaContent += `
        <rd:section id="document">
          <rd:option id="primary-color" value="${emisorData.color}" />
          <rd:option id="accent-color" value="${emisorData.color}" />
          <rd:option id="header-background-color" value="${emisorData.color}" />
        </rd:section>`;
                    hasCustomization = true;
                }
                
                addendaContent += `
      </rd:settings>
    </rd:pdf>
  </rd:style>
</rd:redoc>`;
                
                addendaXml = addendaContent;
                console.log('üé® GENERAR PDF: Addenda XML generada:', {
                    rfc: emisorData?.rfc,
                    tiene_logo_bd: !!emisorData?.logo,
                    logo_status: logoStatus,
                    color_corporativo: emisorData?.color,
                    personalizacion_activa: hasCustomization
                });
            }
            
            // Aplicar addenda si existe personalizaci√≥n corporativa
            if (addendaXml) {
                try {
                    console.log('üé® GENERAR PDF: Aplicando addenda XML al CFDI...');
                    const addenda = redoc.addenda.fromString(addendaXml);
                    cfdi.setAddenda(addenda);
                    console.log('‚úÖ GENERAR PDF: Addenda XML aplicada exitosamente');
                } catch (addendaError) {
                    console.error('‚ùå GENERAR PDF: Error aplicando addenda XML:', addendaError.message);
                    console.log('üìù GENERAR PDF: Continuando sin personalizaci√≥n corporativa');
                }
            } else {
                console.log('üìä GENERAR PDF: Sin personalizaci√≥n corporativa, usando estilo est√°ndar');
            }
            
            // Convertir CFDI a PDF usando el SDK oficial
            const pdf = await cfdi.toPdf();
            
            // Obtener buffer del PDF seg√∫n documentaci√≥n oficial
            const pdfBuffer = pdf.toBuffer();
            const pdfBase64 = pdfBuffer.toString('base64');
            
            console.log('‚úÖ GENERAR PDF: PDF generado exitosamente con SDK oficial');
            console.log('üìä GENERAR PDF: Tama√±o PDF buffer:', pdfBuffer.length, 'bytes');
            console.log('üìä GENERAR PDF: Tama√±o PDF base64:', pdfBase64.length, 'caracteres');
            
            // Extraer metadatos del PDF usando m√©todos oficiales del SDK
            const metadata = {
                transactionId: pdf.getTransactionId(),
                totalPages: pdf.getTotalPages(),
                processTime: pdf.getTotalTimeMs(),
                xmlMeta: pdf.getMetadata()
            };
            
            console.log('üìã GENERAR PDF: Metadatos extra√≠dos del SDK:', metadata);

            // Preparar respuesta exitosa
            const respuesta = {
                success: true,
                mensaje: 'PDF generado exitosamente con SDK oficial',
                pdf: {
                    content: pdfBase64, // PDF en base64
                    size: pdfBase64.length,
                    encoding: 'base64'
                },
                xml: {
                    id: xmlData.id,
                    estado: xmlData.estado,
                    emisor_rfc: xmlData.emisor_rfc,
                    receptor_rfc: xmlData.receptor_rfc,
                    total: xmlData.total
                },
                metadata: metadata,
                timestamp: new Date().toISOString()
            };

            console.log('üéâ GENERAR PDF: Proceso completado exitosamente con SDK');

            return {
                statusCode: 200,
                headers,
                body: JSON.stringify(respuesta)
            };
            
        } catch (sdkError) {
            console.error('‚ùå GENERAR PDF: Error del SDK redoc.mx:', sdkError.message);
            console.error('Stack SDK:', sdkError.stack);
            
            // Si el SDK falla, intentar con API HTTP directa como fallback
            console.log('üîÑ GENERAR PDF: Intentando fallback con API HTTP directa...');
            
            try {
                const httpResult = await generarPdfViaHttp(xmlData.xml_content, redocApiKey, stylePdf);
                
                // Preparar respuesta exitosa del fallback HTTP
                const respuesta = {
                    success: true,
                    mensaje: 'PDF generado exitosamente con API HTTP (fallback)',
                    pdf: {
                        content: httpResult.content,
                        size: httpResult.content.length,
                        encoding: 'base64'
                    },
                    xml: {
                        id: xmlData.id,
                        estado: xmlData.estado,
                        emisor_rfc: xmlData.emisor_rfc,
                        receptor_rfc: xmlData.receptor_rfc,
                        total: xmlData.total
                    },
                    metadata: httpResult.metadata || {},
                    fallback: true,
                    timestamp: new Date().toISOString()
                };

                console.log('üéâ GENERAR PDF: Proceso completado exitosamente con fallback HTTP');

                return {
                    statusCode: 200,
                    headers,
                    body: JSON.stringify(respuesta)
                };
                
            } catch (httpError) {
                console.error('‚ùå GENERAR PDF: Error en fallback HTTP:', httpError.message);
                
                return {
                    statusCode: 500,
                    headers,
                    body: JSON.stringify({
                        error: 'Error en SDK y fallback HTTP',
                        sdkError: sdkError.message,
                        httpError: httpError.message,
                        timestamp: new Date().toISOString()
                    })
                };
            }
        }

    } catch (error) {
        console.error('üí• GENERAR PDF: Error fatal:', error.message);
        console.error('Stack:', error.stack);

        return {
            statusCode: 500,
            headers,
            body: JSON.stringify({
                error: 'Error interno del servidor',
                mensaje: error.message,
                timestamp: new Date().toISOString()
            })
        };
    }
};
